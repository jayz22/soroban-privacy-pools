const fs = require('fs');

/**
 * Compute expected root using lean-imt Rust implementation
 * @param {Object} proof - The merkle proof with leaf, leafIndex, siblings, actualDepth
 * @returns {BigInt} The computed root from lean-imt
 */
function computeExpectedRootLeanIMT(proof) {
    try {
        // Read the lean-imt test results that were generated by the Rust binary
        if (!fs.existsSync('lean_imt_test_results.json')) {
            console.error('Error: lean_imt_test_results.json not found. Run "cargo run --bin lean-imt-test" first.');
            return null;
        }
        
        const testResults = JSON.parse(fs.readFileSync('lean_imt_test_results.json', 'utf8'));
        
        // Find the matching test case
        const matchingTest = testResults.find(test => 
            test.leaf === proof.leaf &&
            test.leaf_index === proof.leafIndex &&
            JSON.stringify(test.siblings) === JSON.stringify(proof.siblings) &&
            test.actual_depth === proof.actualDepth
        );
        
        if (matchingTest) {
            return BigInt(matchingTest.expected_root);
        } else {
            console.error('Error: No matching test case found in lean-imt results');
            return null;
        }
    } catch (error) {
        console.error(`Error reading lean-imt results: ${error.message}`);
        return null;
    }
}

/**
 * Compare lean-imt implementation with expected results
 * @param {Object} proof - The merkle proof
 * @param {BigInt} expectedRoot - The expected root from test data
 * @returns {Object} Comparison results
 */
function compareLeanIMTImplementation(proof, expectedRoot) {
    console.log(`\nüîç Comparing lean-imt implementation for test case:`);
    console.log(`   Leaf: ${proof.leaf}`);
    console.log(`   Leaf Index: ${proof.leafIndex}`);
    console.log(`   Siblings: [${proof.siblings.join(', ')}]`);
    console.log(`   Actual Depth: ${proof.actualDepth}`);
    console.log(`   Expected Root: ${expectedRoot}`);
    
    // Get lean-imt result
    const leanIMTRoot = computeExpectedRootLeanIMT(proof);
    if (leanIMTRoot !== null) {
        console.log(`\nüìä Results:`);
        console.log(`   lean-imt (Rust):        ${leanIMTRoot}`);
        console.log(`   Expected:               ${expectedRoot}`);
        
        // Compare results
        console.log(`\n‚úÖ Comparison Results:`);
        
        if (leanIMTRoot.toString() === expectedRoot.toString()) {
            console.log(`   ‚úÖ lean-imt matches Expected: YES`);
            return { leanIMTRoot, expectedRoot, allMatch: true };
        } else {
            console.log(`   ‚ùå lean-imt matches Expected: NO`);
            console.log(`   üìä Difference: ${leanIMTRoot - expectedRoot}`);
            return { leanIMTRoot, expectedRoot, allMatch: false };
        }
    } else {
        console.log(`\n‚ùå lean-imt computation failed`);
        return { leanIMTRoot: null, expectedRoot, allMatch: false };
    }
}

/**
 * Main function to run lean-imt compatibility tests
 */
function main() {
    const args = process.argv.slice(2);
    
    if (args.length < 1) {
        console.error("Usage: node compute_expected_root_lean_imt.js <test_file>");
        process.exit(1);
    }
    
    const testFile = args[0];
    
    try {
        const testData = JSON.parse(fs.readFileSync(testFile, 'utf8'));
        const expectedRoot = BigInt(testData.expectedRoot);
        
        console.log(`üß™ Running lean-imt compatibility test with: ${testFile}`);
        
        const results = compareLeanIMTImplementation(testData, expectedRoot);
        
        // Return exit code based on results
        if (results.allMatch) {
            process.exit(0);
        } else {
            process.exit(1);
        }
        
    } catch (error) {
        console.error(`Error processing test file: ${error.message}`);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}

module.exports = { 
    computeExpectedRootLeanIMT, 
    compareLeanIMTImplementation 
};
